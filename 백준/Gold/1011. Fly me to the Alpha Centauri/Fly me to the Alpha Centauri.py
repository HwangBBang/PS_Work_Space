# 조건 1 
# 이동거리가 0 이거나 음수일 경우는 무시한다.
# 조건 2
# Kn 은 n 번째의 가능한 이동거리들을 뜻한다.
# 조건 3
# 마지막 이동거리는 1이 되게 해야한다.
# 조건 4
# 가능한 적은 횟수로 이동해야한다.

# 조건 4가지를 종합해보면 이동거리는 /\ 같은 모양일 것이고
# 그때 직선의 기울기는 1과 -1 일 것이다.
# 기울기가 변하는 극대점은 (총 횟수의/2)가 되어야한다. 

# 입력
# x y 가 주어진다

# 첫 이동은 1일 수 밖에 없다. 마지막 이동역시 1이 여야한다.
# x : 0 y : 3 (0,3)
# 1 1 1

# x : 1 y : 5 (0,4)
# 1 2 1

# x : 45 y : 50 (0,5)
# 1 2 1 1

# 주어지는 x,y의 차이가 중요하다.
# y-x = 이동해야하는 거리
# dp로 접근이 가능할 것같다.

# 이동거리가 1이라면?
# 1
# 이동거리가 2이라면?
# 2
# 이동거리가 3이라면?
# 3 111
# 이동거리가 4이라면?
# 3 121
# 이동거리가 5이라면? 
# 4 1211
# 이동거리가 6이라면?
# 4 1221
# 이동거리가 7이라면?
# 5 12211
# 이동거리가 8이라면?
# 5 12221
# 이동거리가 9이라면?
# 5 12321
# 이동거리가 10이라면?
# 6 123211
# 이동거리가 11이라면?
# 6 123221
# 이동거리가 12이라면?
# 6 123321

# 3 2^2   121 
# 5 3^2   12321 
# 7 4^2   1234321
# 9 5^2   123454321
# 11 6^2  12345654321
# 13 7^2  1234567654321

# k^2 = 2k-1 

# k^2+1 ~ k^2+k => 2k

# k^2 +(k+1) ~ (k+1)^2 => 2k+1
t = int(input())

for _ in range(t):
    x,y = map(int,input().split())
    leng = y - x
    if leng < 4:
        print(leng)
    elif leng == 4 :
        print(3)
    else:
        k,result = 0,0
        while 1:
            if (k**2 < leng) and (leng <= (k+1)**2):
                break
            else:
                k += 1
        if k**2+1 <= leng and leng <= k**2+k  :
            result = 2*k
        elif k^2 +(k+1) <= leng and leng <= (k+1)**2 :
            result = 2*k+1
        
        print(result)